{"bitcount": [{"removed_lines": "        n = (n ^ (n - 1));\n", "added_lines": "        n = (n & (n - 1));\n", "removed_line_numbers_range": [15, 1], "added_line_numbers_range": [16, 1], "source_context": "public static int bitcount(int n) {\n    int count = 0;\n    while (n != 0) {\n        n = (n ^ (n - 1));\n        count++;\n    }\n    return count;\n    }"}]}
{"breadth_first_search": [{"removed_lines": "        while (true) {\n", "added_lines": "        while (!queue.isEmpty()) {\n", "removed_line_numbers_range": [24, 1], "added_line_numbers_range": [26, 1], "source_context": "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n        Deque<Node> queue = new ArrayDeque<>();\n        queue.addLast(startnode);\n\n        nodesvisited.add(startnode);\n\n        while (true) {\n            Node node = queue.removeFirst();\n\n            if (node == goalnode) {\n                return true;\n            } else {\n                for (Node successor_node : node.getSuccessors()) {\n                    if (!nodesvisited.contains(successor_node)) {\n                        queue.addFirst(successor_node);\n                        nodesvisited.add(successor_node);\n                    }\n                }\n            }\n        }\n        /**\n         * The buggy program always drops into while(true) loop and will not return false\n         * Removed below line to fix compilation error\n         */\n        // return false;\n    }"}]}
{"bucketsort": [{"removed_lines": "        for (Integer count : arr) { \n", "added_lines": "        for (Integer count : counts) {\n", "removed_line_numbers_range": [22, 1], "added_line_numbers_range": [22, 1], "source_context": "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n        ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n        for (Integer x : arr) {\n            counts.set(x,counts.get(x)+1);\n        }\n\n        ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n        int i = 0;\n        for (Integer count : arr) { // arr is counts in fixed version\n            sorted_arr.addAll(Collections.nCopies(count, i));\n            i++;\n        }\n\n        return sorted_arr;\n    }"}]}
{"depth_first_search": [{"removed_lines": "", "added_lines": "                        nodesvisited.add(node);\n", "removed_line_numbers_range": [21, 0], "added_line_numbers_range": [24, 1], "source_context": "public static boolean depth_first_search(Node startnode, Node goalnode) {\n        Set<Node> nodesvisited = new HashSet<>();\n        class Search {\n            boolean search(Node node) {\n                if (nodesvisited.contains(node)) {\n                    return false;\n                } else if (node == goalnode) {\n                    return true;\n                } else {\n                    for (Node successornodes : node.getSuccessors()) {\n                        if (search(successornodes)) { return true; }\n                    }\n                }\n                return false;\n            }\n        };\n\n        Search s = new Search();\n        return s.search(startnode);\n    }"}]}
{"detect_cycle": [{"removed_lines": "            if (hare.getSuccessor() == null)\n", "added_lines": "            if (null==hare ||hare.getSuccessor() == null)\n", "removed_line_numbers_range": [18, 1], "added_line_numbers_range": [20, 1], "source_context": "public static boolean detect_cycle(Node node) {\n        Node hare = node;\n        Node tortoise = node;\n\n        while (true) {\n            if (hare.getSuccessor() == null)\n                return false;\n\n            tortoise = tortoise.getSuccessor();\n            hare = hare.getSuccessor().getSuccessor();\n\n            if (hare == tortoise)\n                return true;\n        }\n    }"}]}
{"find_first_in_sorted": [{"removed_lines": "        while (lo <= hi) {\n", "added_lines": "        while (lo < hi) {\n", "removed_line_numbers_range": [19, 1], "added_line_numbers_range": [19, 1], "source_context": "public static int find_first_in_sorted(int[] arr, int x) {\n        int lo = 0;\n        int hi = arr.length;\n\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2; // check if this is floor division\n\n            if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                return mid;\n            } else if (x <= arr[mid]) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n\n        return -1;\n    }"}]}
{"find_in_sorted": [{"removed_lines": "            return binsearch(arr, x, mid, end);\n", "added_lines": "            return binsearch(arr, x, mid+1, end);\n", "removed_line_numbers_range": [20, 1], "added_line_numbers_range": [21, 1], "source_context": "public static int binsearch(int[] arr, int x, int start, int end) {\n        if (start == end) {\n            return -1;\n        }\n        int mid = start + (end - start) / 2; // check this is floor division\n        if (x < arr[mid]) {\n            return binsearch(arr, x, start, mid);\n        } else if (x > arr[mid]) {\n            return binsearch(arr, x, mid, end);\n        } else {\n            return mid;\n        }\n    }"}]}
{"flatten": [{"removed_lines": "                    result.add(flatten(x));\n", "added_lines": "                    result.add((x));\n", "removed_line_numbers_range": [21, 1], "added_line_numbers_range": [22, 1], "source_context": "public static Object flatten(Object arr) {\n        if (arr instanceof ArrayList) {\n            ArrayList narr = (ArrayList) arr;\n            ArrayList result = new ArrayList(50);\n            for (Object x : narr) {\n                if (x instanceof ArrayList) {\n                    result.addAll((ArrayList) flatten(x));\n                } else {\n                    result.add(flatten(x));\n                }\n            }\n            return result;\n        } else {\n            return flatten(arr);\n        }\n    }"}, {"removed_lines": "            return flatten(arr);\n", "added_lines": "            return arr;\n", "removed_line_numbers_range": [26, 1], "added_line_numbers_range": [27, 1], "source_context": "public static Object flatten(Object arr) {\n        if (arr instanceof ArrayList) {\n            ArrayList narr = (ArrayList) arr;\n            ArrayList result = new ArrayList(50);\n            for (Object x : narr) {\n                if (x instanceof ArrayList) {\n                    result.addAll((ArrayList) flatten(x));\n                } else {\n                    result.add(flatten(x));\n                }\n            }\n            return result;\n        } else {\n            return flatten(arr);\n        }\n    }"}]}
{"gcd": [{"removed_lines": "            return gcd(a % b, b);\n", "added_lines": "            return gcd(b, a%b);\n", "removed_line_numbers_range": [19, 1], "added_line_numbers_range": [19, 1], "source_context": "public static int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return gcd(a % b, b);\n        }\n    }"}]}
{"get_factors": [{"removed_lines": "        return new ArrayList<Integer>();\n", "added_lines": "\n        return new ArrayList<Integer>(Arrays.asList(n));\n", "removed_line_numbers_range": [27, 1], "added_line_numbers_range": [27, 2], "source_context": "public static ArrayList<Integer> get_factors(int n) {\n        if (n == 1) {\n            return new ArrayList<Integer>();\n        }\n        int max = (int)(Math.sqrt(n) + 1.0);\n        for (int i=2; i < max; i++) {\n            if (n % i == 0) {\n                ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n                prepend.add(i);\n                prepend.addAll(get_factors(n / i));\n                return prepend;\n            }\n        }\n        return new ArrayList<Integer>();\n    }"}]}
{"hanoi": [{"removed_lines": "            steps.add(new Pair<Integer,Integer>(start, helper));\n", "added_lines": "            steps.add(new Pair<Integer,Integer>(start, end));\n", "removed_line_numbers_range": [27, 1], "added_line_numbers_range": [27, 1], "source_context": "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n        ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n\n        if (height > 0) {\n            PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n            crap_set.add(1);\n            crap_set.add(2);\n            crap_set.add(3);\n            crap_set.remove(start);\n            crap_set.remove(end);\n            int helper = crap_set.poll();\n            steps.addAll(hanoi(height-1, start, helper));\n            steps.add(new Pair<Integer,Integer>(start, helper));\n            steps.addAll(hanoi(height-1, helper, end));\n        }\n\n        return steps;\n    }"}]}
{"is_valid_parenthesization": [{"removed_lines": "        return true;\n", "added_lines": "        return depth==0;\n", "removed_line_numbers_range": [24, 1], "added_line_numbers_range": [25, 1], "source_context": "public static Boolean is_valid_parenthesization(String parens) {\n        int depth = 0;\n        for (int i = 0; i < parens.length(); i++) {\n            Character paren = parens.charAt(i);\n            if (paren.equals('(')) {\n                depth++;\n            } else {\n                depth--;\n                if (depth < 0) { return false; }\n            }\n        }\n        return true;\n    }"}]}
{"kheapsort": [{"removed_lines": "        for (Integer x : arr) {\n", "added_lines": "        for (Integer x : arr.subList(k, arr.size())) {\n", "removed_line_numbers_range": [27, 1], "added_line_numbers_range": [28, 1], "source_context": "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n        PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n        for (Integer v : arr.subList(0,k)) {\n            heap.add(v);\n        }\n\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for (Integer x : arr) {\n            heap.add(x);\n            Integer popped = heap.poll();\n            output.add(popped);\n        }\n\n        while (!heap.isEmpty()) {\n            output.add(heap.poll());\n        }\n\n        return output;\n\n    }"}]}
{"knapsack": [{"removed_lines": "                else if (weight < j) {\n", "added_lines": "                else if (weight <= j) {\n", "removed_line_numbers_range": [30, 1], "added_line_numbers_range": [31, 1], "source_context": "public static int knapsack(int capacity, int [][] items) {\n        int weight = 0, value = 0;\n        int n = items.length;\n        int memo[][] = new int[n + 1][capacity + 1];\n\n        for (int i = 0; i <= n ; i++)\n        {\n            if (i - 1 >= 0) {\n                weight = items[i - 1][0];\n                value = items[i - 1][1];\n            }\n            for (int j = 0; j <= capacity; j++)\n            {\n                if (i == 0 || j == 0) {\n                    memo[i][j] = 0;\n                }\n                else if (weight < j) {\n                    memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                }\n                else {\n                    memo[i][j] = memo [i-1][j];\n                }\n\n            }\n        }\n        return memo[n][capacity];\n    }"}]}
{"kth": [{"removed_lines": "            return kth(above, k);\n", "added_lines": "            return kth(above, k-num_lessoreq);\n", "removed_line_numbers_range": [25, 1], "added_line_numbers_range": [32, 1], "source_context": "public static Integer kth(ArrayList<Integer> arr, int k) {\n        int pivot = arr.get(0);\n        ArrayList<Integer> below, above;\n        below = new ArrayList<Integer>(arr.size());\n        above = new ArrayList<Integer>(arr.size());\n        for (Integer x : arr) {\n            if (x < pivot) {\n                below.add(x);\n            } else if (x > pivot) {\n                above.add(x);\n            }\n        }\n\n        int num_less = below.size();\n        int num_lessoreq = arr.size() - above.size();\n        if (k < num_less) {\n            return kth(below, k);\n        } else if (k >= num_lessoreq) {\n            return kth(above, k);\n        } else {\n            return pivot;\n        }\n    }"}]}
{"lcs_length": [{"removed_lines": "                    if (dp.containsKey(i-1)) {\n", "added_lines": "                \n                    if (dp.containsKey(i-1)&&dp.get(i-1).containsKey(j-1)) {\n", "removed_line_numbers_range": [35, 1], "added_line_numbers_range": [36, 2], "source_context": "public static Integer lcs_length(String s, String t) {\n        // make a Counter\n        // pair? no! just hashtable to a hashtable.. woo.. currying\n\n        Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n\n        // just set all the internal maps to 0\n        for (int i=0; i < s.length(); i++) {\n            Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n            dp.put(i, initialize);\n            for (int j=0; j < t.length(); j++) {\n                Map<Integer,Integer> internal_map = dp.get(i);\n                internal_map.put(j,0);\n                dp.put(i, internal_map);\n            }\n        }\n\n        // now the actual code\n        for (int i=0; i < s.length(); i++) {\n            for (int j=0; j < t.length(); j++) {\n                if (s.charAt(i) == t.charAt(j)) {\n\n                    if (dp.containsKey(i-1)) {\n                        Map<Integer, Integer> internal_map = dp.get(i);\n                        int insert_value = dp.get(i-1).get(j) + 1;\n                        internal_map.put(j, insert_value);\n                        dp.put(i,internal_map);\n                    } else {\n                        Map<Integer, Integer> internal_map = dp.get(i);\n                        internal_map.put(j,1);\n                        dp.put(i,internal_map);\n                    }\n                }\n            }\n        }\n\n        if (!dp.isEmpty()) {\n            List<Integer> ret_list = new ArrayList<Integer>();\n            for (int i=0; i<s.length(); i++) {\n                ret_list.add(!dp.get(i).isEmpty() ? Collections.max(dp.get(i).values()) : 0);\n            }\n            return Collections.max(ret_list);\n        } else {\n            return 0;\n        }\n    }"}, {"removed_lines": "                        int insert_value = dp.get(i-1).get(j) + 1;\n", "added_lines": "                        int insert_value = dp.get(i-1).get(j-1) + 1;\n", "removed_line_numbers_range": [37, 1], "added_line_numbers_range": [39, 1], "source_context": "public static Integer lcs_length(String s, String t) {\n        // make a Counter\n        // pair? no! just hashtable to a hashtable.. woo.. currying\n\n        Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n\n        // just set all the internal maps to 0\n        for (int i=0; i < s.length(); i++) {\n            Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n            dp.put(i, initialize);\n            for (int j=0; j < t.length(); j++) {\n                Map<Integer,Integer> internal_map = dp.get(i);\n                internal_map.put(j,0);\n                dp.put(i, internal_map);\n            }\n        }\n\n        // now the actual code\n        for (int i=0; i < s.length(); i++) {\n            for (int j=0; j < t.length(); j++) {\n                if (s.charAt(i) == t.charAt(j)) {\n\n                    if (dp.containsKey(i-1)) {\n                        Map<Integer, Integer> internal_map = dp.get(i);\n                        int insert_value = dp.get(i-1).get(j) + 1;\n                        internal_map.put(j, insert_value);\n                        dp.put(i,internal_map);\n                    } else {\n                        Map<Integer, Integer> internal_map = dp.get(i);\n                        internal_map.put(j,1);\n                        dp.put(i,internal_map);\n                    }\n                }\n            }\n        }\n\n        if (!dp.isEmpty()) {\n            List<Integer> ret_list = new ArrayList<Integer>();\n            for (int i=0; i<s.length(); i++) {\n                ret_list.add(!dp.get(i).isEmpty() ? Collections.max(dp.get(i).values()) : 0);\n            }\n            return Collections.max(ret_list);\n        } else {\n            return 0;\n        }\n    }"}]}
{"levenshtein": [{"removed_lines": "            return 1 + levenshtein(source.substring(1), target.substring(1));\n", "added_lines": "            return levenshtein(source.substring(1), target.substring(1));\n", "removed_line_numbers_range": [17, 1], "added_line_numbers_range": [17, 1], "source_context": "public static int levenshtein(String source, String target) {\n        if (source.isEmpty() || target.isEmpty()) {\n            return source.isEmpty() ? target.length() : source.length();\n        } else if (source.charAt(0) == target.charAt(0)) {\n            return 1 + levenshtein(source.substring(1), target.substring(1));\n        } else {\n            return 1 + Math.min(Math.min(\n                    levenshtein(source,              target.substring(1)),\n                    levenshtein(source.substring(1), target.substring(1))),\n                    levenshtein(source.substring(1), target)\n        );\n        }\n    }"}]}
{"lis": [{"removed_lines": "                longest = length + 1;\n", "added_lines": "                longest = Math.max(longest,length + 1);\n", "removed_line_numbers_range": [31, 1], "added_line_numbers_range": [31, 1], "source_context": "public static int lis(int[] arr) {\n        Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n        int longest = 0;\n\n        int i = 0;\n        for (int val : arr) {\n\n            ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n            for (int j=1; j < longest+1; j++) {\n                if (arr[ends.get(j)] < val) {\n                    prefix_lengths.add(j);\n                }\n            }\n\n            int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n\n            if (length == longest || val < arr[ends.get(length+1)]) {\n                ends.put(length+1, i);\n                longest = length + 1;\n            }\n\n            i++;\n        }\n        return longest;\n    }"}]}
{"longest_common_subsequence": [{"removed_lines": "            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n", "added_lines": "            return a.charAt(0) + longest_common_subsequence(a.substring(1), b.substring(1));\n", "removed_line_numbers_range": [18, 1], "added_line_numbers_range": [18, 1], "source_context": "public static String longest_common_subsequence(String a, String b) {\n        if (a.isEmpty() || b.isEmpty()) {\n            return \"\";\n        } else if (a.charAt(0) == b.charAt(0)) {\n            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n        } else {\n            String fst = longest_common_subsequence(a, b.substring(1));\n            String snd = longest_common_subsequence(a.substring(1), b);\n            return fst.length() >= snd.length() ? fst : snd;\n        }\n\n    }"}]}
{"max_sublist_sum": [{"removed_lines": "            max_ending_here = max_ending_here + x;\n", "added_lines": "            max_ending_here = Math.max(0,max_ending_here + x);\n", "removed_line_numbers_range": [19, 1], "added_line_numbers_range": [19, 1], "source_context": "public static int max_sublist_sum(int[] arr) {\n        int max_ending_here = 0;\n        int max_so_far = 0;\n\n        for (int x : arr) {\n            max_ending_here = max_ending_here + x;\n            max_so_far = Math.max(max_so_far, max_ending_here);\n        }\n\n        return max_so_far;\n    }"}]}
{"mergesort": [{"removed_lines": "        if (arr.size() == 0) { \n", "added_lines": "        if (arr.size() <= 1) { \n", "removed_line_numbers_range": [38, 1], "added_line_numbers_range": [38, 1], "source_context": "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        if (arr.size() == 0) { // <= 1 in correct version\n            return arr;\n        } else {\n            int middle = arr.size() / 2;\n            ArrayList<Integer> left = new ArrayList<Integer>(100);\n            left.addAll(arr.subList(0,middle));\n            left = mergesort(left);\n            ArrayList<Integer> right = new ArrayList<Integer>(100);\n            right.addAll(arr.subList(middle, arr.size()));\n            right = mergesort(right);\n\n            return merge(left, right);\n        }\n    }"}]}
{"minimum_spanning_tree": [{"removed_lines": "                    groupByNode = update(groupByNode, node, vertex_u);\n", "added_lines": "                    groupByNode.put(node,  groupByNode.get(vertex_u));\n", "removed_line_numbers_range": [28, 1], "added_line_numbers_range": [31, 1], "source_context": "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n                    groupByNode = update(groupByNode, node, vertex_u);\n                }\n            }\n        }\n        return minSpanningTree;\n    }"}]}
{"next_palindrome": [{"removed_lines": "        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n", "added_lines": "        otherwise.addAll(Collections.nCopies(digit_list.length-1, 0));\n", "removed_line_numbers_range": [35, 1], "added_line_numbers_range": [35, 1], "source_context": "public static String next_palindrome(int[] digit_list) {\n        int high_mid = Math.floorDiv(digit_list.length, 2);\n        int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n\n        while (high_mid < digit_list.length && low_mid >= 0) {\n            if (digit_list[high_mid] == 9) {\n                digit_list[high_mid] = 0;\n                digit_list[low_mid] = 0;\n                high_mid += 1;\n                low_mid -= 1;\n            } else {\n                digit_list[high_mid] += 1;\n                if (low_mid != high_mid) {\n                    digit_list[low_mid] += 1;\n                }\n                return Arrays.toString(digit_list);\n            }\n        }\n\n        ArrayList<Integer> otherwise = new ArrayList<Integer>();\n        otherwise.add(1);\n        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n        otherwise.add(1);\n\n        return String.valueOf(otherwise);\n    }"}]}
{"next_permutation": [{"removed_lines": "                    if (perm.get(j) < perm.get(i)) {\n", "added_lines": "                    if (perm.get(j) > perm.get(i)) {\n", "removed_line_numbers_range": [19, 1], "added_line_numbers_range": [19, 1], "source_context": "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n        for (int i=perm.size()-2; i!=-1; i--) {\n            if (perm.get(i) < perm.get(i+1)) {\n                for (int j=perm.size()-1; j!=i; j--) {\n                    if (perm.get(j) < perm.get(i)) {\n                        ArrayList<Integer> next_perm = perm;\n                        int temp_j = perm.get(j);\n                        int temp_i = perm.get(i);\n                        next_perm.set(i,temp_j);\n                        next_perm.set(j,temp_i);\n\n                        ArrayList<Integer> reversed = new ArrayList<Integer>(100);\n                        for (int k=next_perm.size()-1; k!=i; k--) {\n                            reversed.add(next_perm.get(k));\n                        }\n\n                        int q = i + 1;\n                        for (Integer replace : reversed) {\n                            next_perm.set(q, replace);\n                            q++;\n                        }\n\n                        return next_perm;\n                    }\n                }\n            }\n        }\n\n        return new ArrayList<Integer>();\n    }"}]}
{"pascal": [{"removed_lines": "            for (int c=0; c<r; c++) {\n", "added_lines": "            for (int c=0; c<r+1; c++) {\n", "removed_line_numbers_range": [22, 1], "added_line_numbers_range": [22, 1], "source_context": "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n        ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n        ArrayList<Integer> init = new ArrayList<Integer>();\n        init.add(1);\n        rows.add(init);\n\n        for (int r=1; r<n; r++) {\n            ArrayList<Integer> row = new ArrayList<Integer>();\n            for (int c=0; c<r; c++) {\n                int upleft, upright;\n                if (c > 0) {\n                    upleft = rows.get(r-1).get(c-1);\n                } else {\n                    upleft = 0;\n                }\n                if (c < r) {\n                    upright = rows.get(r-1).get(c);\n                } else {\n                    upright = 0;\n                }\n                row.add(upleft+upright);\n            }\n            rows.add(row);\n        }\n\n        return rows;\n    }"}]}
{"possible_change": [{"removed_lines": "        if (total < 0) {\n", "added_lines": "        if (total < 0 ||coins.length==0) {\n", "removed_line_numbers_range": [17, 1], "added_line_numbers_range": [17, 1], "source_context": "public static int possible_change(int[] coins, int total) {\n        if (total == 0) {\n            return 1;\n        }\n        if (total < 0) {\n            return 0;\n        }\n\n        int first = coins[0];\n        int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n        return possible_change(coins, total-first) + possible_change(rest, total);\n    }"}]}
{"powerset": [{"removed_lines": "            to_add.add(first);\n", "added_lines": "\n", "removed_line_numbers_range": [23, 1], "added_line_numbers_range": [24, 1], "source_context": "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n        if (!arr.isEmpty()) {\n            Object first = arr.get(0);\n            arr.remove(0);\n            ArrayList rest = arr;\n            ArrayList<ArrayList> rest_subsets = powerset(rest);\n\n            ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n            ArrayList to_add = new ArrayList(100);\n            to_add.add(first);\n            for (ArrayList subset : rest_subsets) {\n                to_add.addAll(subset);\n            }\n            output.add(to_add);\n\n            return output;\n        } else {\n            ArrayList empty_set = new ArrayList<ArrayList>();\n            empty_set.add(new ArrayList());\n            return empty_set;\n        }\n    }"}, {"removed_lines": "                to_add.addAll(subset);\n", "added_lines": "                ArrayList r = new ArrayList();\n                r.add(first);\n                r.addAll(subset);\n                to_add.add(r);\n", "removed_line_numbers_range": [25, 1], "added_line_numbers_range": [26, 4], "source_context": "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n        if (!arr.isEmpty()) {\n            Object first = arr.get(0);\n            arr.remove(0);\n            ArrayList rest = arr;\n            ArrayList<ArrayList> rest_subsets = powerset(rest);\n\n            ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n            ArrayList to_add = new ArrayList(100);\n            to_add.add(first);\n            for (ArrayList subset : rest_subsets) {\n                to_add.addAll(subset);\n            }\n            output.add(to_add);\n\n            return output;\n        } else {\n            ArrayList empty_set = new ArrayList<ArrayList>();\n            empty_set.add(new ArrayList());\n            return empty_set;\n        }\n    }"}, {"removed_lines": "            output.add(to_add);\n", "added_lines": "", "removed_line_numbers_range": [27, 1], "added_line_numbers_range": [30, 0], "source_context": "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n        if (!arr.isEmpty()) {\n            Object first = arr.get(0);\n            arr.remove(0);\n            ArrayList rest = arr;\n            ArrayList<ArrayList> rest_subsets = powerset(rest);\n\n            ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n            ArrayList to_add = new ArrayList(100);\n            to_add.add(first);\n            for (ArrayList subset : rest_subsets) {\n                to_add.addAll(subset);\n            }\n            output.add(to_add);\n\n            return output;\n        } else {\n            ArrayList empty_set = new ArrayList<ArrayList>();\n            empty_set.add(new ArrayList());\n            return empty_set;\n        }\n    }"}, {"removed_lines": "            return output;\n", "added_lines": "            output.addAll(to_add);\n            rest_subsets.addAll(output);\n\n            return rest_subsets;\n", "removed_line_numbers_range": [29, 1], "added_line_numbers_range": [32, 4], "source_context": "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n        if (!arr.isEmpty()) {\n            Object first = arr.get(0);\n            arr.remove(0);\n            ArrayList rest = arr;\n            ArrayList<ArrayList> rest_subsets = powerset(rest);\n\n            ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n            ArrayList to_add = new ArrayList(100);\n            to_add.add(first);\n            for (ArrayList subset : rest_subsets) {\n                to_add.addAll(subset);\n            }\n            output.add(to_add);\n\n            return output;\n        } else {\n            ArrayList empty_set = new ArrayList<ArrayList>();\n            empty_set.add(new ArrayList());\n            return empty_set;\n        }\n    }"}]}
{"quicksort": [{"removed_lines": "            } else if (x > pivot) {\n", "added_lines": "            } else if (x >= pivot) {\n", "removed_line_numbers_range": [26, 1], "added_line_numbers_range": [26, 1], "source_context": "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n        if (arr.isEmpty()) {\n            return new ArrayList<Integer>();\n        }\n\n        Integer pivot = arr.get(0);\n        ArrayList<Integer> lesser = new ArrayList<Integer>();\n        ArrayList<Integer> greater = new ArrayList<Integer>();\n\n        for (Integer x : arr.subList(1, arr.size())) {\n            if (x < pivot) {\n                lesser.add(x);\n            } else if (x > pivot) {\n                greater.add(x);\n            }\n        }\n        ArrayList<Integer> middle = new ArrayList<Integer>();\n        middle.add(pivot);\n        lesser = quicksort(lesser);\n        greater = quicksort(greater);\n        middle.addAll(greater);\n        lesser.addAll(middle);\n        return lesser;\n\n    }"}]}
{"reverse_linked_list": [{"removed_lines": "", "added_lines": "            prevnode = node;\n", "removed_line_numbers_range": [19, 0], "added_line_numbers_range": [22, 1], "source_context": "public static Node reverse_linked_list(Node node) {\n        Node prevnode = null;\n        Node nextnode;\n        while (node != null) {\n            nextnode = node.getSuccessor();\n            node.setSuccessor(prevnode);\n            node = nextnode;\n        }\n        return prevnode;\n    }"}]}
{"rpn_eval": [{"removed_lines": "                c = bin_op.apply(a,b);\n", "added_lines": "                c = bin_op.apply(b,a);\n", "removed_line_numbers_range": [34, 1], "added_line_numbers_range": [34, 1], "source_context": "public static Double rpn_eval(ArrayList tokens) {\n        Map<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\n        op.put(\"+\", (a, b) -> a + b);\n        op.put(\"-\", (a, b) -> a - b);\n        op.put(\"*\", (a, b) -> a * b);\n        op.put(\"/\", (a, b) -> a / b);\n\n\n        Stack stack = new Stack();\n\n        for (Object token : tokens) {\n            if (Double.class.isInstance(token)) {\n                stack.push((Double) token);\n            } else {\n                token = (String) token;\n                Double a = (Double) stack.pop();\n                Double b = (Double) stack.pop();\n                Double c = 0.0;\n                BinaryOperator<Double> bin_op = op.get(token);\n                c = bin_op.apply(a,b);\n                stack.push(c);\n            }\n        }\n\n        return (Double) stack.pop();\n    }"}]}
{"shortest_path_length": [{"removed_lines": "                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n", "added_lines": "                        distance + length_by_edge.get(Arrays.asList(node, nextnode))));\n", "removed_line_numbers_range": [38, 1], "added_line_numbers_range": [40, 1], "source_context": "public static int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n        int n = length_by_edge.size();\n        // the shortest distance from source to each node\n        Map<Node, Integer> unvisitedNodes = new HashMap<>();\n        Set<Node> visitedNodes = new HashSet<>();\n\n        unvisitedNodes.put(startnode, 0);\n\n        while (!unvisitedNodes.isEmpty()) {\n            Node node = getNodeWithMinDistance(unvisitedNodes);\n            int distance = unvisitedNodes.get(node);\n            unvisitedNodes.remove(node);\n\n            if (node.getValue() == goalnode.getValue()) {\n                return distance;\n            }\n            visitedNodes.add(node);\n\n            for (Node nextnode : node.getSuccessors()) {\n                if (visitedNodes.contains(nextnode)) {\n                    continue;\n                }\n\n                if (unvisitedNodes.get(nextnode) == null) {\n                    unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                }\n\n                unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n            }\n        }\n\n        return Integer.MAX_VALUE;\n    }"}]}
{"shortest_path_lengths": [{"removed_lines": "                                                            length_by_path.get(Arrays.asList(j,k))));\n", "added_lines": "                                                            length_by_path.get(Arrays.asList(k,j))));\n\n", "removed_line_numbers_range": [37, 1], "added_line_numbers_range": [37, 2], "source_context": "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n        Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n        for (int i = 0; i < numNodes; i++) {\n            for (int j =0; j < numNodes; j++) {\n                List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n                if (i == j) {\n                    length_by_path.put(edge, 0);\n                }\n                else if (length_by_edge.containsKey(edge) ) {\n                    length_by_path.put(edge, length_by_edge.get(edge));\n                } else {\n                    length_by_path.put(edge, INF);\n                }\n            }\n        }\n        for (int k = 0; k < numNodes; k++) {\n            for (int i = 0; i < numNodes; i++) {\n                for (int j = 0; j < numNodes; j++) {\n                    int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                 sumLengths(length_by_path.get(Arrays.asList(i,k)),\n                                                            length_by_path.get(Arrays.asList(j,k))));\n                    length_by_path.put(Arrays.asList(i,j), update_length);\n                }\n            }\n        }\n        return length_by_path;\n    }"}]}
{"shortest_paths": [{"removed_lines": "                weight_by_edge.put(edge, update_weight);\n", "added_lines": "\n                weight_by_node.put(edge.get(1), update_weight);\n", "removed_line_numbers_range": [30, 1], "added_line_numbers_range": [34, 2], "source_context": "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n                weight_by_edge.put(edge, update_weight);\n            }\n        }\n        return weight_by_node;\n    }"}]}
{"shunting_yard": [{"removed_lines": "", "added_lines": "                opstack.push(token);\n", "removed_line_numbers_range": [32, 0], "added_line_numbers_range": [34, 1], "source_context": "public static List shunting_yard(ArrayList tokens) {\n        Map<String, Integer> precedence = new HashMap<String, Integer>();\n        precedence.put(\"+\",1);\n        precedence.put(\"-\",1);\n        precedence.put(\"*\",2);\n        precedence.put(\"/\",2);\n\n        ArrayList rpntokens = new ArrayList(100);\n        ArrayDeque opstack = new ArrayDeque();\n\n        for (Object token: tokens) {\n            if (Integer.class.isInstance(token)) {\n            // cover also Double case I guess?\n                rpntokens.add((Integer) token);\n            } else {\n                String operator = (String) token;\n                while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                    rpntokens.add(opstack.pop());\n                }\n            }\n        }\n\n        while (!opstack.isEmpty()) {\n            rpntokens.add(opstack.pop());\n        }\n\n        return rpntokens;\n    }"}]}
{"sieve": [{"removed_lines": "            if (any(list_comp(n, primes))) {\n", "added_lines": "            if (all(list_comp(n, primes))) {\n", "removed_line_numbers_range": [41, 1], "added_line_numbers_range": [41, 1], "source_context": "public static ArrayList<Integer> sieve(Integer max) {\n        ArrayList<Integer> primes = new ArrayList<Integer>();\n        for (int n=2; n<max+1; n++) {\n            if (any(list_comp(n, primes))) {\n                primes.add(n);\n            }\n        }\n        return primes;\n    }"}]}
{"sqrt": [{"removed_lines": "        while (Math.abs(x-approx) > epsilon) {\n", "added_lines": "        while (Math.abs(x-approx*approx) > epsilon) {\n", "removed_line_numbers_range": [16, 1], "added_line_numbers_range": [16, 1], "source_context": "public static double sqrt(double x, double epsilon) {\n        double approx = x / 2d;\n        while (Math.abs(x-approx) > epsilon) {\n            approx = 0.5d * (approx + x / approx);\n        }\n        return approx;\n    }"}]}
{"subsequences": [{"removed_lines": "            return new ArrayList();\n", "added_lines": "            ArrayList empty_set = new ArrayList<ArrayList>();\n            empty_set.add(new ArrayList());\n            return empty_set;\n", "removed_line_numbers_range": [16, 1], "added_line_numbers_range": [16, 3], "source_context": "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n        if (k == 0) {\n            return new ArrayList();\n        }\n\n        ArrayList ret = new ArrayList(50);\n        for (int i=a; i<b+1-k; i++) {\n            ArrayList base = new ArrayList(50);\n            for (ArrayList rest : subsequences(i+1, b, k-1)) {\n                rest.add(0,i);\n                base.add(rest);\n            }\n            ret.addAll(base);\n\n        }\n\n        return ret;\n    }"}]}
{"to_base": [{"removed_lines": "            result = result + String.valueOf(alphabet.charAt(i));\n", "added_lines": "            result = String.valueOf(alphabet.charAt(i))+result;\n", "removed_line_numbers_range": [21, 1], "added_line_numbers_range": [21, 1], "source_context": "public static String to_base(int num, int b) {\n        String result = \"\";\n        String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        int i;\n        while (num > 0) {\n            i = num % b;\n            num = num / b; // floor division?\n            result = result + String.valueOf(alphabet.charAt(i));\n        }\n\n        return result;\n    }"}]}
{"topological_ordering": [{"removed_lines": "                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n", "added_lines": "                if (orderedNodes.containsAll(nextNode.getPredecessors()) && !orderedNodes.contains(nextNode)) {\n", "removed_line_numbers_range": [17, 1], "added_line_numbers_range": [19, 1], "source_context": "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n        ArrayList<Node> orderedNodes = new ArrayList<Node>();\n        for (Node node : directedGraph) {\n            if (node.getPredecessors().isEmpty()) {\n                orderedNodes.add(node);\n            }\n        }\n\n        int listSize = orderedNodes.size();\n        for (int i = 0; i < listSize; i++) {\n            Node node = orderedNodes.get(i);\n            for (Node nextNode : node.getSuccessors()) {\n                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n                    orderedNodes.add(nextNode);\n                    listSize++;\n                }\n            }\n        }\n        return orderedNodes;\n    }"}]}
{"wrap": [{"removed_lines": "\n", "added_lines": "        lines.add(text);\n", "removed_line_numbers_range": [31, 1], "added_line_numbers_range": [31, 1], "source_context": "public static ArrayList<String> wrap(String text, int cols) {\n        ArrayList<String> lines = new ArrayList<String>();\n\n        String line;\n        while (text.length() > cols) {\n            int end = text.lastIndexOf(\" \", cols); // off by one?\n            if (end == -1) {\n                end = cols;\n            }\n            line = text.substring(0,end);\n            text = text.substring(end);\n            lines.add(line);\n        }\n\n        return lines;\n    }"}]}
