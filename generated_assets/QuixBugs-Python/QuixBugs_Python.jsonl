{"bitcount": [{"removed_lines": "        n ^= n - 1\n", "added_lines": "        n &= n - 1\n", "removed_line_numbers_range": [5, 1], "added_line_numbers_range": [5, 1], "source_context": "def bitcount(n):\n    count = 0\n    while n:\n        n ^= n - 1\n        count += 1\n    return count", "source_identifiers": []}]}
{"breadth_first_search": [{"removed_lines": "    while True:\n", "added_lines": "    while queue:\n", "removed_line_numbers_range": [11, 1], "added_line_numbers_range": [11, 1], "source_context": "def breadth_first_search(startnode, goalnode):\n    queue = Queue()\n    queue.append(startnode)\n\n    nodesseen = set()\n    nodesseen.add(startnode)\n\n    while True:\n        node = queue.popleft()\n\n        if node is goalnode:\n            return True\n        else:\n            queue.extend(node for node in node.successors if node not in nodesseen)\n            nodesseen.update(node.successors)\n\n    return False", "source_identifiers": []}]}
{"bucketsort": [{"removed_lines": "    for i, count in enumerate(arr):\n", "added_lines": "    for i, count in enumerate(counts):\n", "removed_line_numbers_range": [7, 1], "added_line_numbers_range": [8, 1], "source_context": "def bucketsort(arr, k):\n    counts = [0] * k\n    for x in arr:\n        counts[x] += 1\n\n    sorted_arr = []\n    for i, count in enumerate(arr):\n        sorted_arr.extend([i] * count)\n\n    return sorted_arr", "source_identifiers": []}]}
{"depth_first_search": [{"removed_lines": "", "added_lines": "            nodesvisited.add(node)\n", "removed_line_numbers_range": [9, 0], "added_line_numbers_range": [11, 1], "source_context": "def depth_first_search(startnode, goalnode):\n    nodesvisited = set()\n\n    def search_from(node):\n        if node in nodesvisited:\n            return False\n        elif node is goalnode:\n            return True\n        else:\n            return any(\n                search_from(nextnode) for nextnode in node.successors\n            )\n\n    return search_from(startnode)", "source_identifiers": []}]}
{"detect_cycle": [{"removed_lines": "        if hare.successor is None:\n", "added_lines": "        if hare is None or hare.successor is None:\n", "removed_line_numbers_range": [5, 1], "added_line_numbers_range": [5, 1], "source_context": "def detect_cycle(node):\n    hare = tortoise = node\n\n    while True:\n        if hare.successor is None:\n            return False\n\n        tortoise = tortoise.successor\n        hare = hare.successor.successor\n\n        if hare is tortoise:\n            return True", "source_identifiers": []}]}
{"find_first_in_sorted": [{"removed_lines": "    while lo <= hi:\n", "added_lines": "    while lo < hi:\n", "removed_line_numbers_range": [5, 1], "added_line_numbers_range": [6, 1], "source_context": "def find_first_in_sorted(arr, x):\n    lo = 0\n    hi = len(arr)\n\n    while lo <= hi:\n        mid = (lo + hi) // 2\n\n        if x == arr[mid] and (mid == 0 or x != arr[mid - 1]):\n            return mid\n\n        elif x <= arr[mid]:\n            hi = mid\n\n        else:\n            lo = mid + 1\n\n    return -1", "source_identifiers": []}]}
{"find_in_sorted": [{"removed_lines": "            return binsearch(mid, end)\n", "added_lines": "            return binsearch(mid + 1, end)\n", "removed_line_numbers_range": [9, 1], "added_line_numbers_range": [10, 1], "source_context": "def find_in_sorted(arr, x):\n    def binsearch(start, end):\n        if start == end:\n            return -1\n        mid = start + (end - start) // 2\n        if x < arr[mid]:\n            return binsearch(start, mid)\n        elif x > arr[mid]:\n            return binsearch(mid, end)\n        else:\n            return mid\n\n    return binsearch(0, len(arr))", "source_identifiers": []}]}
{"flatten": [{"removed_lines": "            yield flatten(x)\n", "added_lines": "            yield x\n", "removed_line_numbers_range": [7, 1], "added_line_numbers_range": [8, 1], "source_context": "def flatten(arr):\n    for x in arr:\n        if isinstance(x, list):\n            for y in flatten(x):\n                yield y\n        else:\n            yield flatten(x)", "source_identifiers": []}]}
{"gcd": [{"removed_lines": "        return gcd(a % b, b)\n", "added_lines": "        return gcd(b, a % b)\n", "removed_line_numbers_range": [5, 1], "added_line_numbers_range": [6, 1], "source_context": "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(a % b, b)", "source_identifiers": []}]}
{"get_factors": [{"removed_lines": "    return []\n", "added_lines": "    return [n]\n", "removed_line_numbers_range": [10, 1], "added_line_numbers_range": [10, 1], "source_context": "def get_factors(n):\n    if n == 1:\n        return []\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return [i] + get_factors(n // i)\n\n    return []", "source_identifiers": []}]}
{"hanoi": [{"removed_lines": "        steps.append((start, helper))\n", "added_lines": "        steps.append((start, end))\n", "removed_line_numbers_range": [6, 1], "added_line_numbers_range": [7, 1], "source_context": "def hanoi(height, start=1, end=3):\n    steps = []\n    if height > 0:\n        helper = ({1, 2, 3} - {start} - {end}).pop()\n        steps.extend(hanoi(height - 1, start, helper))\n        steps.append((start, helper))\n        steps.extend(hanoi(height - 1, helper, end))\n\n    return steps", "source_identifiers": []}]}
{"is_valid_parenthesization": [{"removed_lines": "    return True\n", "added_lines": "    return depth == 0\n", "removed_line_numbers_range": [12, 1], "added_line_numbers_range": [12, 1], "source_context": "def is_valid_parenthesization(parens):\n    depth = 0\n    for paren in parens:\n        if paren == '(':\n            depth += 1\n        else:\n            depth -= 1\n            if depth < 0:\n                return False\n\n    return True", "source_identifiers": []}]}
{"kheapsort": [{"removed_lines": "    for x in arr:\n", "added_lines": "    for x in arr[k:]:\n", "removed_line_numbers_range": [7, 1], "added_line_numbers_range": [8, 1], "source_context": "def kheapsort(arr, k):\n    import heapq\n\n    heap = arr[:k]\n    heapq.heapify(heap)\n\n    for x in arr:\n        yield heapq.heappushpop(heap, x)\n\n    while heap:\n        yield heapq.heappop(heap)", "source_identifiers": []}]}
{"knapsack": [{"removed_lines": "            if weight < j:\n", "added_lines": "            if weight <= j:\n", "removed_line_numbers_range": [12, 1], "added_line_numbers_range": [12, 1], "source_context": "def knapsack(capacity, items):\n    from collections import defaultdict\n    memo = defaultdict(int)\n\n    for i in range(1, len(items) + 1):\n        weight, value = items[i - 1]\n\n        for j in range(1, capacity + 1):\n            memo[i, j] = memo[i - 1, j]\n\n            if weight < j:\n                memo[i, j] = max(\n                    memo[i, j],\n                    value + memo[i - 1, j - weight]\n                )\n\n    return memo[len(items), capacity]", "source_identifiers": []}]}
{"kth": [{"removed_lines": "        return kth(above, k)\n", "added_lines": "        return kth(above, k - num_lessoreq)\n", "removed_line_numbers_range": [12, 1], "added_line_numbers_range": [13, 1], "source_context": "def kth(arr, k):\n    pivot = arr[0]\n    below = [x for x in arr if x < pivot]\n    above = [x for x in arr if x > pivot]\n\n    num_less = len(below)\n    num_lessoreq = len(arr) - len(above)\n\n    if k < num_less:\n        return kth(below, k)\n    elif k >= num_lessoreq:\n        return kth(above, k)\n    else:\n        return pivot", "source_identifiers": []}]}
{"lcs_length": [{"removed_lines": "                dp[i, j] = dp[i - 1, j] + 1\n", "added_lines": "                dp[i, j] = dp[i - 1, j - 1] + 1\n", "removed_line_numbers_range": [9, 1], "added_line_numbers_range": [10, 1], "source_context": "def lcs_length(s, t):\n    from collections import Counter\n\n    dp = Counter()\n\n    for i in range(len(s)):\n        for j in range(len(t)):\n            if s[i] == t[j]:\n                dp[i, j] = dp[i - 1, j] + 1\n\n    return max(dp.values()) if dp else 0", "source_identifiers": []}]}
{"levenshtein": [{"removed_lines": "        return 1 + levenshtein(source[1:], target[1:])\n", "added_lines": "        return levenshtein(source[1:], target[1:])\n", "removed_line_numbers_range": [6, 1], "added_line_numbers_range": [7, 1], "source_context": "def levenshtein(source, target):\n    if source == '' or target == '':\n        return len(source) or len(target)\n\n    elif source[0] == target[0]:\n        return 1 + levenshtein(source[1:], target[1:])\n\n    else:\n        return 1 + min(\n            levenshtein(source,     target[1:]),\n            levenshtein(source[1:], target[1:]),\n            levenshtein(source[1:], target)\n        )", "source_identifiers": []}]}
{"lis": [{"removed_lines": "            longest = length + 1\n", "added_lines": "            longest = max(longest, length + 1)\n", "removed_line_numbers_range": [14, 1], "added_line_numbers_range": [14, 1], "source_context": "def lis(arr):\n    ends = {}\n    longest = 0\n\n    for i, val in enumerate(arr):\n\n        prefix_lengths = [j for j in range(1, longest + 1) if arr[ends[j]] < val]\n\n        length = max(prefix_lengths) if prefix_lengths else 0\n\n        if length == longest or val < arr[ends[length + 1]]:\n            ends[length + 1] = i\n            longest = length + 1\n\n    return longest", "source_identifiers": []}]}
{"longest_common_subsequence": [{"removed_lines": "        return a[0] + longest_common_subsequence(a[1:], b)\n", "added_lines": "        return a[0] + longest_common_subsequence(a[1:], b[1:])\n", "removed_line_numbers_range": [6, 1], "added_line_numbers_range": [7, 1], "source_context": "def longest_common_subsequence(a, b):\n    if not a or not b:\n        return ''\n\n    elif a[0] == b[0]:\n        return a[0] + longest_common_subsequence(a[1:], b)\n\n    else:\n        return max(\n            longest_common_subsequence(a, b[1:]),\n            longest_common_subsequence(a[1:], b),\n            key=len\n        )", "source_identifiers": []}]}
{"max_sublist_sum": [{"removed_lines": "        max_ending_here = max_ending_here + x\n", "added_lines": "        max_ending_here = max(0, max_ending_here + x)\n", "removed_line_numbers_range": [7, 1], "added_line_numbers_range": [7, 1], "source_context": "def max_sublist_sum(arr):\n    max_ending_here = 0\n    max_so_far = 0\n\n    for x in arr:\n        max_ending_here = max_ending_here + x\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far", "source_identifiers": []}]}
{"mergesort": [{"removed_lines": "    if len(arr) == 0:\n", "added_lines": "    if len(arr) <= 1:\n", "removed_line_numbers_range": [17, 1], "added_line_numbers_range": [17, 1], "source_context": "def mergesort(arr):\n    def merge(left, right):\n        result = []\n        i = 0\n        j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:] or right[j:])\n        return result\n\n    if len(arr) == 0:\n        return arr\n    else:\n        middle = len(arr) // 2\n        left = mergesort(arr[:middle])\n        right = mergesort(arr[middle:])\n        return merge(left, right)", "source_identifiers": []}]}
{"minimum_spanning_tree": [{"removed_lines": "                group_by_node[node].update(group_by_node[u])\n", "added_lines": "                group_by_node[node] = group_by_node[u]\n", "removed_line_numbers_range": [12, 1], "added_line_numbers_range": [12, 1], "source_context": "def minimum_spanning_tree(weight_by_edge):\n    group_by_node = {}\n    mst_edges = set()\n\n    for edge in sorted(weight_by_edge, key=weight_by_edge.__getitem__):\n        u, v = edge\n        if group_by_node.setdefault(u, {u}) != group_by_node.setdefault(v, {v}):\n            mst_edges.add(edge)\n            group_by_node[u].update(group_by_node[v])\n            for node in group_by_node[v]:\n                group_by_node[node].update(group_by_node[u])\n\n    return mst_edges", "source_identifiers": []}]}
{"next_palindrome": [{"removed_lines": "    return [1] + (len(digit_list)) * [0] + [1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "added_lines": "    return [1] + (len(digit_list) - 1) * [0] + [1]\n", "removed_line_numbers_range": [15, 19], "added_line_numbers_range": [15, 1], "source_context": "def next_palindrome(digit_list):\n    high_mid = len(digit_list) // 2\n    low_mid = (len(digit_list) - 1) // 2\n    while high_mid < len(digit_list) and low_mid >= 0:\n        if digit_list[high_mid] == 9:\n            digit_list[high_mid] = 0\n            digit_list[low_mid] = 0\n            high_mid += 1\n            low_mid -= 1\n        else:\n            digit_list[high_mid] += 1\n            if low_mid != high_mid:\n                digit_list[low_mid] += 1\n            return digit_list\n    return [1] + (len(digit_list)) * [0] + [1]", "source_identifiers": []}]}
{"next_permutation": [{"removed_lines": "                if perm[j] < perm[i]:\n", "added_lines": "                if perm[i] < perm[j]:\n", "removed_line_numbers_range": [6, 1], "added_line_numbers_range": [6, 1], "source_context": "def next_permutation(perm):\n    for i in range(len(perm) - 2, -1, -1):\n        if perm[i] < perm[i + 1]:\n            for j in range(len(perm) - 1, i, -1):\n                if perm[j] < perm[i]:\n                    next_perm = list(perm)\n                    next_perm[i], next_perm[j] = perm[j], perm[i]\n                    next_perm[i + 1:] = reversed(next_perm[i + 1:])\n                    return next_perm", "source_identifiers": []}]}
{"pascal": [{"removed_lines": "        for c in range(0, r):\n", "added_lines": "        for c in range(0, r + 1):\n", "removed_line_numbers_range": [6, 1], "added_line_numbers_range": [6, 1], "source_context": "def pascal(n):\n    rows = [[1]]\n    for r in range(1, n):\n        row = []\n        for c in range(0, r):\n            upleft = rows[r - 1][c - 1] if c > 0 else 0\n            upright = rows[r - 1][c] if c < r else 0\n            row.append(upleft + upright)\n        rows.append(row)\n\n    return rows", "source_identifiers": []}]}
{"possible_change": [{"removed_lines": "    if total < 0:\n", "added_lines": "    if total < 0 or not coins:\n", "removed_line_numbers_range": [5, 1], "added_line_numbers_range": [5, 1], "source_context": "def possible_change(coins, total):\n    if total == 0:\n        return 1\n    if total < 0:\n        return 0\n\n    first, *rest = coins\n    return possible_change(coins, total - first) + possible_change(rest, total)", "source_identifiers": []}]}
{"powerset": [{"removed_lines": "        return [[first] + subset for subset in rest_subsets]\n", "added_lines": "        return rest_subsets + [[first] + subset for subset in rest_subsets]\n", "removed_line_numbers_range": [6, 1], "added_line_numbers_range": [6, 1], "source_context": "def powerset(arr):\n    if arr:\n        first, *rest = arr #python3 just like car and cdr (in this case anyway..)\n        rest_subsets = powerset(rest)\n        return [[first] + subset for subset in rest_subsets]\n    else:\n        return [[]]", "source_identifiers": []}]}
{"quicksort": [{"removed_lines": "    greater = quicksort([x for x in arr[1:] if x > pivot])\n", "added_lines": "    greater = quicksort([x for x in arr[1:] if x >= pivot])\n", "removed_line_numbers_range": [7, 1], "added_line_numbers_range": [8, 1], "source_context": "def quicksort(arr):\n    if not arr:\n        return []\n\n    pivot = arr[0]\n    lesser = quicksort([x for x in arr[1:] if x < pivot])\n    greater = quicksort([x for x in arr[1:] if x > pivot])\n    return lesser + [pivot] + greater", "source_identifiers": []}]}
{"reverse_linked_list": [{"removed_lines": "", "added_lines": "        prevnode = node\n", "removed_line_numbers_range": [5, 0], "added_line_numbers_range": [7, 1], "source_context": "def reverse_linked_list(node):\n    prevnode = None\n    while node:\n        nextnode = node.successor\n        node.successor = prevnode\n        node = nextnode\n    return prevnode", "source_identifiers": []}]}
{"rpn_eval": [{"removed_lines": "                op(token, a, b)\n", "added_lines": "                op(token, b, a)\n", "removed_line_numbers_range": [20, 1], "added_line_numbers_range": [20, 1], "source_context": "def rpn_eval(tokens):\n    def op(symbol, a, b):\n        return {\n            '+': lambda a, b: a + b,\n            '-': lambda a, b: a - b,\n            '*': lambda a, b: a * b,\n            '/': lambda a, b: a / b\n        }[symbol](a, b)\n\n    stack = []\n\n    for token in tokens:\n        if isinstance(token, float):\n            stack.append(token)\n        else:\n            a = stack.pop()\n            b = stack.pop()\n            stack.append(\n                op(token, a, b)\n            )\n\n    return stack.pop()", "source_identifiers": []}]}
{"shortest_path_length": [{"removed_lines": "                    get(unvisited_nodes, nextnode) + length_by_edge[node, nextnode]\n", "added_lines": "                    distance + length_by_edge[node, nextnode]\n", "removed_line_numbers_range": [22, 1], "added_line_numbers_range": [22, 1], "source_context": "def shortest_path_length(length_by_edge, startnode, goalnode):\n    unvisited_nodes = [] # FibHeap containing (node, distance) pairs\n    heappush(unvisited_nodes, (0, startnode))\n    visited_nodes = set()\n\n    while len(unvisited_nodes) > 0:\n        distance, node = heappop(unvisited_nodes)\n        if node is goalnode:\n            return distance\n\n        visited_nodes.add(node)\n\n        for nextnode in node.successors:\n            if nextnode in visited_nodes:\n                continue\n\n            insert_or_update(unvisited_nodes,\n                (min(\n                    get(unvisited_nodes, nextnode) or float('inf'),\n                    get(unvisited_nodes, nextnode) + length_by_edge[node, nextnode]\n                ),\n                nextnode)\n            )\n\n    return float('inf')", "source_identifiers": []}]}
{"shortest_path_lengths": [{"removed_lines": "                    length_by_path[i, k] + length_by_path[j, k]\n", "added_lines": "                    length_by_path[i, k] + length_by_path[k, j]\n", "removed_line_numbers_range": [13, 1], "added_line_numbers_range": [14, 1], "source_context": "def shortest_path_lengths(n, length_by_edge):\n    length_by_path = defaultdict(lambda: float('inf'))\n    length_by_path.update({(i, i): 0 for i in range(n)})\n    length_by_path.update(length_by_edge)\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                length_by_path[i, j] = min(\n                    length_by_path[i, j],\n                    length_by_path[i, k] + length_by_path[j, k]\n                )\n\n    return length_by_path", "source_identifiers": []}]}
{"shortest_paths": [{"removed_lines": "            weight_by_edge[u, v] = min(\n", "added_lines": "            weight_by_node[v] = min(\n", "removed_line_numbers_range": [10, 1], "added_line_numbers_range": [10, 1], "source_context": "def shortest_paths(source, weight_by_edge):\n    weight_by_node = {\n        v: float('inf') for u, v in weight_by_edge\n    }\n    weight_by_node[source] = 0\n\n    for i in range(len(weight_by_node) - 1):\n        for (u, v), weight in weight_by_edge.items():\n            weight_by_edge[u, v] = min(\n                weight_by_node[u] + weight,\n                weight_by_node[v]\n            )\n\n    return weight_by_node", "source_identifiers": []}]}
{"shunting_yard": [{"removed_lines": "", "added_lines": "            opstack.append(token)\n", "removed_line_numbers_range": [17, 0], "added_line_numbers_range": [18, 1], "source_context": "def shunting_yard(tokens):\n    precedence = {\n        '+': 1,\n        '-': 1,\n        '*': 2,\n        '/': 2\n    }\n\n    rpntokens = []\n    opstack = []\n    for token in tokens:\n        if isinstance(token, int):\n            rpntokens.append(token)\n        else:\n            while opstack and precedence[token] <= precedence[opstack[-1]]:\n                rpntokens.append(opstack.pop())\n\n    while opstack:\n        rpntokens.append(opstack.pop())\n\n    return rpntokens", "source_identifiers": []}]}
{"sieve": [{"removed_lines": "        if any(n % p > 0 for p in primes):\n", "added_lines": "        if all(n % p > 0 for p in primes):\n", "removed_line_numbers_range": [4, 1], "added_line_numbers_range": [5, 1], "source_context": "def sieve(max):\n    primes = []\n    for n in range(2, max + 1):\n        if any(n % p > 0 for p in primes):\n            primes.append(n)\n    return primes", "source_identifiers": []}]}
{"sqrt": [{"removed_lines": "    while abs(x - approx) > epsilon:\n", "added_lines": "    while abs(x - approx ** 2) > epsilon:\n", "removed_line_numbers_range": [4, 1], "added_line_numbers_range": [4, 1], "source_context": "def sqrt(x, epsilon):\n    approx = x / 2\n    while abs(x - approx) > epsilon:\n        approx = 0.5 * (approx + x / approx)\n    return approx", "source_identifiers": []}]}
{"subsequences": [{"removed_lines": "        return []\n", "added_lines": "        return [[]]\n", "removed_line_numbers_range": [3, 1], "added_line_numbers_range": [4, 1], "source_context": "def subsequences(a, b, k):\n    if k == 0:\n        return []\n\n    ret = []\n    for i in range(a, b + 1 - k):\n        ret.extend(\n            [i] + rest for rest in subsequences(i + 1, b, k - 1)\n        )\n\n    return ret", "source_identifiers": []}]}
{"to_base": [{"removed_lines": "        result = result + alphabet[i]\n", "added_lines": "        result = alphabet[i] + result\n", "removed_line_numbers_range": [9, 1], "added_line_numbers_range": [9, 1], "source_context": "def to_base(num, b):\n    result = ''\n    alphabet = string.digits + string.ascii_uppercase\n    while num > 0:\n        i = num % b\n        num = num // b\n        result = result + alphabet[i]\n    return result", "source_identifiers": []}]}
{"topological_ordering": [{"removed_lines": "            if set(ordered_nodes).issuperset(nextnode.outgoing_nodes) and nextnode not in ordered_nodes:\n", "added_lines": "            if set(ordered_nodes).issuperset(nextnode.incoming_nodes) and nextnode not in ordered_nodes:\n", "removed_line_numbers_range": [6, 1], "added_line_numbers_range": [6, 1], "source_context": "def topological_ordering(nodes):\n    ordered_nodes = [node for node in nodes if not node.incoming_nodes]\n\n    for node in ordered_nodes:\n        for nextnode in node.outgoing_nodes:\n            if set(ordered_nodes).issuperset(nextnode.outgoing_nodes) and nextnode not in ordered_nodes:\n                ordered_nodes.append(nextnode)\n\n    return ordered_nodes", "source_identifiers": []}]}
{"wrap": [{"removed_lines": "", "added_lines": "    lines.append(text)\n", "removed_line_numbers_range": [9, 0], "added_line_numbers_range": [11, 1], "source_context": "def wrap(text, cols):\n    lines = []\n    while len(text) > cols:\n        end = text.rfind(' ', 0, cols + 1)\n        if end == -1:\n            end = cols\n        line, text = text[:end], text[end:]\n        lines.append(line)\n\n    return lines", "source_identifiers": []}]}
