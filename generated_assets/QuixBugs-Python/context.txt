def bitcount(n): count = 0 while n: n ^= n - 1 count += 1 return count
def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode)  nodesseen = set() nodesseen.add(startnode)  while True: node = queue.popleft()  if node is goalnode: return True else: queue.extend(node for node in node.successors if node not in nodesseen) nodesseen.update(node.successors)  return False
def bucketsort(arr, k): counts = [0] * k for x in arr: counts[x] += 1  sorted_arr = [] for i, count in enumerate(arr): sorted_arr.extend([i] * count)  return sorted_arr
def depth_first_search(startnode, goalnode): nodesvisited = set()  def search_from(node): if node in nodesvisited: return False elif node is goalnode: return True else: return any( search_from(nextnode) for nextnode in node.successors )  return search_from(startnode)
def detect_cycle(node): hare = tortoise = node  while True: if hare.successor is None: return False  tortoise = tortoise.successor hare = hare.successor.successor  if hare is tortoise: return True
def find_first_in_sorted(arr, x): lo = 0 hi = len(arr)  while lo <= hi: mid = (lo + hi) // 2  if x == arr[mid] and (mid == 0 or x != arr[mid - 1]): return mid  elif x <= arr[mid]: hi = mid  else: lo = mid + 1  return -1
def find_in_sorted(arr, x): def binsearch(start, end): if start == end: return -1 mid = start + (end - start) // 2 if x < arr[mid]: return binsearch(start, mid) elif x > arr[mid]: return binsearch(mid, end) else: return mid  return binsearch(0, len(arr))
def flatten(arr): for x in arr: if isinstance(x, list): for y in flatten(x): yield y else: yield flatten(x)
def gcd(a, b): if b == 0: return a else: return gcd(a % b, b)
def get_factors(n): if n == 1: return []  for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return [i] + get_factors(n // i)  return []
def hanoi(height, start=1, end=3): steps = [] if height > 0: helper = ({1, 2, 3} - {start} - {end}).pop() steps.extend(hanoi(height - 1, start, helper)) steps.append((start, helper)) steps.extend(hanoi(height - 1, helper, end))  return steps
def is_valid_parenthesization(parens): depth = 0 for paren in parens: if paren == '(': depth += 1 else: depth -= 1 if depth < 0: return False  return True
def kheapsort(arr, k): import heapq  heap = arr[:k] heapq.heapify(heap)  for x in arr: yield heapq.heappushpop(heap, x)  while heap: yield heapq.heappop(heap)
def knapsack(capacity, items): from collections import defaultdict memo = defaultdict(int)  for i in range(1, len(items) + 1): weight, value = items[i - 1]  for j in range(1, capacity + 1): memo[i, j] = memo[i - 1, j]  if weight < j: memo[i, j] = max( memo[i, j], value + memo[i - 1, j - weight] )  return memo[len(items), capacity]
def kth(arr, k): pivot = arr[0] below = [x for x in arr if x < pivot] above = [x for x in arr if x > pivot]  num_less = len(below) num_lessoreq = len(arr) - len(above)  if k < num_less: return kth(below, k) elif k >= num_lessoreq: return kth(above, k) else: return pivot
def lcs_length(s, t): from collections import Counter  dp = Counter()  for i in range(len(s)): for j in range(len(t)): if s[i] == t[j]: dp[i, j] = dp[i - 1, j] + 1  return max(dp.values()) if dp else 0
def levenshtein(source, target): if source == '' or target == '': return len(source) or len(target)  elif source[0] == target[0]: return 1 + levenshtein(source[1:], target[1:])  else: return 1 + min( levenshtein(source,     target[1:]), levenshtein(source[1:], target[1:]), levenshtein(source[1:], target) )
def lis(arr): ends = {} longest = 0  for i, val in enumerate(arr):  prefix_lengths = [j for j in range(1, longest + 1) if arr[ends[j]] < val]  length = max(prefix_lengths) if prefix_lengths else 0  if length == longest or val < arr[ends[length + 1]]: ends[length + 1] = i longest = length + 1  return longest
def longest_common_subsequence(a, b): if not a or not b: return ''  elif a[0] == b[0]: return a[0] + longest_common_subsequence(a[1:], b)  else: return max( longest_common_subsequence(a, b[1:]), longest_common_subsequence(a[1:], b), key=len )
def max_sublist_sum(arr): max_ending_here = 0 max_so_far = 0  for x in arr: max_ending_here = max_ending_here + x max_so_far = max(max_so_far, max_ending_here)  return max_so_far
def mergesort(arr): def merge(left, right): result = [] i = 0 j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:] or right[j:]) return result  if len(arr) == 0: return arr else: middle = len(arr) // 2 left = mergesort(arr[:middle]) right = mergesort(arr[middle:]) return merge(left, right)
def minimum_spanning_tree(weight_by_edge): group_by_node = {} mst_edges = set()  for edge in sorted(weight_by_edge, key=weight_by_edge.__getitem__): u, v = edge if group_by_node.setdefault(u, {u}) != group_by_node.setdefault(v, {v}): mst_edges.add(edge) group_by_node[u].update(group_by_node[v]) for node in group_by_node[v]: group_by_node[node].update(group_by_node[u])  return mst_edges
def next_palindrome(digit_list): high_mid = len(digit_list) // 2 low_mid = (len(digit_list) - 1) // 2 while high_mid < len(digit_list) and low_mid >= 0: if digit_list[high_mid] == 9: digit_list[high_mid] = 0 digit_list[low_mid] = 0 high_mid += 1 low_mid -= 1 else: digit_list[high_mid] += 1 if low_mid != high_mid: digit_list[low_mid] += 1 return digit_list return [1] + (len(digit_list)) * [0] + [1]
def next_permutation(perm): for i in range(len(perm) - 2, -1, -1): if perm[i] < perm[i + 1]: for j in range(len(perm) - 1, i, -1): if perm[j] < perm[i]: next_perm = list(perm) next_perm[i], next_perm[j] = perm[j], perm[i] next_perm[i + 1:] = reversed(next_perm[i + 1:]) return next_perm
def pascal(n): rows = [[1]] for r in range(1, n): row = [] for c in range(0, r): upleft = rows[r - 1][c - 1] if c > 0 else 0 upright = rows[r - 1][c] if c < r else 0 row.append(upleft + upright) rows.append(row)  return rows
def possible_change(coins, total): if total == 0: return 1 if total < 0: return 0  first, *rest = coins return possible_change(coins, total - first) + possible_change(rest, total)
def powerset(arr): if arr: first, *rest = arr #python3 just like car and cdr (in this case anyway..) rest_subsets = powerset(rest) return [[first] + subset for subset in rest_subsets] else: return [[]]
def quicksort(arr): if not arr: return []  pivot = arr[0] lesser = quicksort([x for x in arr[1:] if x < pivot]) greater = quicksort([x for x in arr[1:] if x > pivot]) return lesser + [pivot] + greater
def reverse_linked_list(node): prevnode = None while node: nextnode = node.successor node.successor = prevnode node = nextnode return prevnode
def rpn_eval(tokens): def op(symbol, a, b): return { '+': lambda a, b: a + b, '-': lambda a, b: a - b, '*': lambda a, b: a * b, '/': lambda a, b: a / b }[symbol](a, b)  stack = []  for token in tokens: if isinstance(token, float): stack.append(token) else: a = stack.pop() b = stack.pop() stack.append( op(token, a, b) )  return stack.pop()
def shortest_path_length(length_by_edge, startnode, goalnode): unvisited_nodes = [] # FibHeap containing (node, distance) pairs heappush(unvisited_nodes, (0, startnode)) visited_nodes = set()  while len(unvisited_nodes) > 0: distance, node = heappop(unvisited_nodes) if node is goalnode: return distance  visited_nodes.add(node)  for nextnode in node.successors: if nextnode in visited_nodes: continue  insert_or_update(unvisited_nodes, (min( get(unvisited_nodes, nextnode) or float('inf'), get(unvisited_nodes, nextnode) + length_by_edge[node, nextnode] ), nextnode) )  return float('inf')
def shortest_path_lengths(n, length_by_edge): length_by_path = defaultdict(lambda: float('inf')) length_by_path.update({(i, i): 0 for i in range(n)}) length_by_path.update(length_by_edge)  for k in range(n): for i in range(n): for j in range(n): length_by_path[i, j] = min( length_by_path[i, j], length_by_path[i, k] + length_by_path[j, k] )  return length_by_path
def shortest_paths(source, weight_by_edge): weight_by_node = { v: float('inf') for u, v in weight_by_edge } weight_by_node[source] = 0  for i in range(len(weight_by_node) - 1): for (u, v), weight in weight_by_edge.items(): weight_by_edge[u, v] = min( weight_by_node[u] + weight, weight_by_node[v] )  return weight_by_node
def shunting_yard(tokens): precedence = { '+': 1, '-': 1, '*': 2, '/': 2 }  rpntokens = [] opstack = [] for token in tokens: if isinstance(token, int): rpntokens.append(token) else: while opstack and precedence[token] <= precedence[opstack[-1]]: rpntokens.append(opstack.pop())  while opstack: rpntokens.append(opstack.pop())  return rpntokens
def sieve(max): primes = [] for n in range(2, max + 1): if any(n % p > 0 for p in primes): primes.append(n) return primes
def sqrt(x, epsilon): approx = x / 2 while abs(x - approx) > epsilon: approx = 0.5 * (approx + x / approx) return approx
def subsequences(a, b, k): if k == 0: return []  ret = [] for i in range(a, b + 1 - k): ret.extend( [i] + rest for rest in subsequences(i + 1, b, k - 1) )  return ret
def to_base(num, b): result = '' alphabet = string.digits + string.ascii_uppercase while num > 0: i = num % b num = num // b result = result + alphabet[i] return result
def topological_ordering(nodes): ordered_nodes = [node for node in nodes if not node.incoming_nodes]  for node in ordered_nodes: for nextnode in node.outgoing_nodes: if set(ordered_nodes).issuperset(nextnode.outgoing_nodes) and nextnode not in ordered_nodes: ordered_nodes.append(nextnode)  return ordered_nodes
def wrap(text, cols): lines = [] while len(text) > cols: end = text.rfind(' ', 0, cols + 1) if end == -1: end = cols line, text = text[:end], text[end:] lines.append(line)  return lines
